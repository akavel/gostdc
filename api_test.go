package internal

import (
	"encoding/hex"
	. "testing"
)

func TestOpenClose(t *T) {
	l := Open()
	l.Close()
}

func TestStackBasic(t *T) {
	l := Open()
	defer l.Close()

	n := l.Gettop()
	if n != 0 {
		t.Error(n)
	}

	stack := []int{5, 5, 0}
	for i, x := range stack {
		l.Pushinteger(x)
		n = l.Gettop()
		if n != i+1 {
			t.Error("expected", i+1, "got", n)
		}
	}

	eqs := []struct {
		i1, i2 int
		eq     int // 1=true, 0=false
	}{
		{-1, -2, 0},
		{-2, -3, 1},
		{1, 2, 1},
		{2, 3, 0},
	}
	for _, x := range eqs {
		if l.Equal(x.i1, x.i2) != x.eq {
			t.Error("expected", x)
		}
	}
}

// "return 2+3", generated by '../gen_chunk.lua'
var chunk1 = "\x1bLuaQ\x00\x01\x04\x04\x04\x08\x00\x01\x00\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x02\x03\x00\x00\x00" +
	"\x01\x00\x00\x00\x1e\x00\x00\x01\x1e\x00\x80\x00\x01\x00\x00" +
	"\x00\x03\x00\x00\x00\x00\x00\x00\x14@\x00\x00\x00\x00\x03\x00" +
	"\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x00" +
	"\x00\x00\x00\x00\x00\x00\x00"

func TestRunPrecompiled(t *T) {
	cases := []struct {
		chunk string
		stack []int
	}{
		{chunk1, []int{5}},
	}

	for i, c := range cases {
		l := Open()

		r := l.Loadbuffer([]byte(c.chunk), "") //TODO: chunk name is currently ignored

		if r != 0 {
			t.Error("case", i, "got error", r, "when loading")
		}

		l.Call(0, len(c.stack)) //TODO: also LUA_MULTRET
		if l.Gettop() != len(c.stack) {
			t.Error("case", i, "unexpected returned stack size", l.Gettop())
		}

		for j := range c.stack {
			l.Pushinteger(c.stack[j])
			if l.Equal(1+j, -1) == 0 {
				t.Error("case", i, "wrong value at stack position", j)
			}
		}
		l.Close()
	}
}

func TestNumStrConv(t *T) {
	cases := []struct {
		n float64
		s string
	}{
		{1.001, "1.001"},
	}

	for i, x := range cases {
		l := Open()
		l.Pushnumber(x.n)
		s := string(l.Tolstring(-1))
		if s != x.s {
			t.Error("case", i, "wrong string", s)
		}
		l.Close()
	}

	for i, x := range cases {
		l := Open()
		l.Pushlstring([]byte(x.s))
		n := l.Tonumber(-1)
		if n != x.n {
			t.Error("case", i, "wrong number", n)
		}
		l.Close()
	}
}

func TestDumpPrecompiled(t *T) {
	cases := [][]byte{[]byte(chunk1)}

	for i, c := range cases {
		l := Open()
		var buf []byte

		r := l.Loadbuffer(c, "") //TODO: chunk name is currently ignored
		if r != 0 {
			t.Error("case", i, "got error", r, "when loading")
			goto cont
		}
		t.Log("case", i, "loaded chunk of size", len(c))

		r = l.Dump(func(L State, pbuf, size uintptr, userdata interface{}) int {
			t.Log("case", i, "got", size, "bytes to dump...")
			for i := uintptr(0); i < size; i++ {
				buf = append(buf, *peek(pbuf + i))
			}
			return 0
		}, nil)
		if r != 0 {
			t.Error("case", i, "got error", r, "when dumping")
			goto cont
		}

		t.Log(hex.EncodeToString(c))
		t.Log(hex.EncodeToString(buf))
		if len(buf) != len(c) {
			t.Error("case", i, "bad length", len(buf), "of dumped chunk, expected", len(c))
		}
		for j := 0; j < len(buf) && j < len(c); j++ {
			if buf[j] != c[j] {
				t.Error("case", i, "diff at offset", j, "got", buf[j], "expected", c[j])
			}
		}

	cont:
		l.Close()
	}
}

func TestParseAndRun(t *T) {
	cases := []struct {
		chunk string
		stack []string
	}{
		{"return 4+5", []string{"9"}},
	}

	for i, c := range cases {
		l := Open()

		r := l.Loadbuffer([]byte(c.chunk), "")
		if r != 0 {
			t.Error("case", i, "got error", r, "when loading")
			goto cont
		}

		l.Call(0, len(c.stack))

		if l.Gettop() != len(c.stack) {
			t.Error("case", i, "stack size expected", len(c.stack), "got", l.Gettop())
		}

		for j := range c.stack {
			res := string(l.Tolstring(j + 1))
			if res != c.stack[j] {
				t.Error("case", i, "stack position", j, "got", res)
			}
		}

	cont:
		l.Close()
	}
}
